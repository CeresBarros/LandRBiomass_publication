---
title: "LandR Publication Simulations"
author: "Ceres Barros"
date: "22/01/2021"
output:
  html_document:
    keep_md: yes
editor_options:
  chunk_output_type: console
---

# A simplified example of publication runs
For full code used in publication see `global.R`

```{r setup, include=FALSE}
isInteractive <- interactive()
knitr::opts_chunk$set(echo = TRUE, eval = isInteractive, results = "hold",
                      cache = 2) ## TODO: set 'eval = TRUE'
```

## Package installation
```{pkgInstall}
if (!exists("pkgDir")) {
  pkgDir <- file.path("packages", version$platform,
                      paste0(version$major, ".", strsplit(version$minor, "[.]")[[1]][1]))

  if (!dir.exists(pkgDir)) {
    dir.create(pkgDir, recursive = TRUE)
  }
  .libPaths(pkgDir)
}

if (!require("devtools")) {
  install.packages("devtools", lib = pkgDir)
}

if (!require("Require")) {
  install.packages("Require", lib = pkgDir)
  library(Require)
}

if (!require("SpaDES")) {
  install.packages("SpaDES", dependencies = TRUE, lib = pkgDir)
}

devtools::install_github("PredictiveEcology/SpaDES.core@8a7886a6afd7f3b90df10ea6b87caae8661f8709")
devtools::install_github("PredictiveEcology/LandR@093c39898912a6e89ac9b6e862733052a0fae407")
devtools::install_github("ianmseddy/LandR.CS@b39c8c72d20189fa6b6aeb057cdc751a631e0efa")
devtools::install_github("PredictiveEcology/reproducible@aedea49637a6ebd0db6897f1d33f53959f41bee2")
devtools::install_github("PredictiveEcology/SpaDES.install@80c43dcb94d897d25545105a7b83111cf634a556")
devtools::install_github("PredictiveEcology/SpaDES.experiment@5a23c40f8aa9a9efc6dc16e040f8771561059152")

out <- SpaDES.install::makeSureAllPackagesInstalled(modulePath = "R/SpaDES/m")
```

## Package setup
```{r init, eval = TRUE, results = FALSE}
library(Require)
Require(c("SpaDES",
          "raster", "dplyr", "data.table", "future",
          "PredictiveEcology/SpaDES.experiment",
          "PredictiveEcology/LandR@development (>= 1.0.5.9003)",
          "PredictiveEcology/reproducible (>= 1.2.7.9011)"), upgrade = FALSE)

options("reproducible.useNewDigestAlgorith" = 2)
options("spades.moduleCodeChecks" = FALSE)
options("reproducible.useCache" = TRUE)
options("reproducible.inputPaths" = file.path("R/SpaDES/inputs"))
options("reproducible.destinationPath" = file.path("R/SpaDES/inputs"))
options("reproducible.useGDAL" = FALSE)

## set run name and paths
runName <- "baseCase"
eventCaching <- c(".inputObjects", "init")
useParallel <- FALSE

## paths
simDirName <- "sep2021Runs"
simPaths <- list(cachePath = file.path("R/SpaDES/cache", simDirName)
                 , modulePath = file.path("R/SpaDES/m")
                 , inputPath = file.path("R/SpaDES/inputs")
                 , outputPath = file.path("R/SpaDES/outputs", simDirName))
```

## Simulation setup - part 1 

### Get study area and other necessary objects 

```{r simulationSetup}
## Get necessary objects -----------------------
source("R/SpaDES/1_simObjects.R")
```

## Simulation setup - part 2 - species layers

```{r simulationSetup2}
## Run Biomass_speciesData to get species layers
## running this separately from other modules makes switching
## between using a large and a smaller study area easier when the smaller SA is within the large one,
## as it keeps the data in separate folders thatn can be used across simulations/scenarios
source("R/SpaDES/2_speciesLayers.R")

## check species layers:
# plot(simOutSpeciesLayers$speciesLayers)
## Populus grandidentata shouldn't be in SK (and has v. few pixels in the layer) and will be excluded "manually"
toRm <- which(names(simOutSpeciesLayers$speciesLayers) %in% c("Popu_Gra"))
simOutSpeciesLayers$speciesLayers <- dropLayer(simOutSpeciesLayers$speciesLayers, i = toRm)
rm(toRm)

## subset sppEquivalencies
sppEquivalencies_CA <- sppEquivalencies_CA[Boreal %in% names(simOutSpeciesLayers$speciesLayers)]

## Get land-cover raster now that we have a rasterToMatchLarge
rstLCC2005 <- LandR::prepInputsLCC(
  year = 2005L,
  destinationPath = simPaths$inputPath,
  studyArea = simOutSpeciesLayers$studyAreaLarge,   ## Ceres: makePixel table needs same no. pixels for this, RTM rawBiomassMap, LCC.. etc
  rasterToMatch = simOutSpeciesLayers$rasterToMatchLarge,
  filename2 = .suffix("rstLCC.tif", paste0("_", SAname)),
  overwrite = TRUE,
  cacheRepo = simPaths$cachePath,
  userTags = c("rstLCC", SAname),
  omitArgs = c("userTags"))
```

```{r loadSppLayers, include=FALSE, eval = !isInteractive}
simOutSpeciesLayers <- qs::qread(file.path("GitHubActionsSims", simDirName, runName, paste0("simList_speciesLayers", runName)))

## subset sppEquivalencies
sppEquivalencies_CA <- sppEquivalencies_CA[Boreal %in% names(simOutSpeciesLayers$speciesLayers)]

## Get land-cover raster now that we have a rasterToMatchLarge
rstLCC2005 <- raster(file.path("GitHubActionsSims", simDirName, runName, "rstLCC_3cda4aed011c168c.tif"))
```

## Simulation setup - part 3 - module parameters and outputs

* `vegLeadingProportion` indicates what proportion the stand must be in one species group for it to be leading.
  If 0, then there is never a notion of "mixed" vegetation types and a species is a leading species if it has the highest relative biomass in the pixel.
* `successionTimestep` defines the frequency at which dispersal and age reclassification occurs - every 10 years is the default LANDIS behaviour. 

```{r simulationSetup3}
## simulation params
simTimes <- list(start = 2001, end = 2031)
vegLeadingProportion <- 0 
successionTimestep <- 10L  

speciesParams <- list(
  "shadetolerance" = list(
    Betu_Pap = 1,
    Lari_Lar = 1,
    Pice_Gla = 2,
    Pice_Mar = 3,
    Pinu_Ban = 1.5,
    Popu_Spp = 1
  )
)

simModules <- list("Biomass_borealDataPrep"
                   , "Biomass_speciesParameters"
                   , "Biomass_core"
)

simParams <- list(
  Biomass_borealDataPrep = list(
    "sppEquivCol" = sppEquivCol
    , "forestedLCCClasses" = c(1:15, 34:35)
    , "LCCClassesToReplaceNN" = c(34:35)
    , "fitDeciduousCoverDiscount" = TRUE
    , "subsetDataAgeModel" = FALSE
    , "subsetDataBiomassModel" = FALSE
    , "exportModels" = "all"
    , "fixModelBiomass" = TRUE
    , "speciesTableAreas" = c("BSW", "BP")
    , "speciesUpdateFunction" = list(
      quote(LandR::speciesTableUpdate(sim$species, sim$speciesTable, sim$sppEquiv, P(sim)$sppEquivCol)),
      quote(LandR::updateSpeciesTable(speciesTable = sim$species, params = sim$speciesParams)))
    # next two are used when assigning pixelGroup membership; what resolution for
    #   age and biomass
    , "pixelGroupAgeClass" = successionTimestep
    , "pixelGroupBiomassClass" = 100
    , "useCloudCacheForStats" = FALSE
    , "cloudFolderID" = NA
    , ".plots" = c("object", "raw")
    , ".useCache" = eventCaching
  )
  , Biomass_speciesParameters = list(
    "quantileAgeSubset" = list(Betu_Pap = 95, Lari_Lar = 95, Pice_Gla = 95, Pice_Mar = 95, Pinu_Ban = 99, Popu_Spp = 99)
    , "sppEquivCol" = sppEquivCol
    , ".useCache" = eventCaching
  )
  , Biomass_core = list(
    "calcSummaryBGM" = c("start")
    , "initialBiomassSource" = "cohortData" 
    , "plotOverstory" = TRUE
    , "seedingAlgorithm" = "wardDispersal"
    , "sppEquivCol" = sppEquivCol
    , "successionTimestep" = successionTimestep
    , "vegLeadingProportion" = vegLeadingProportion
    , ".plotInitialTime" = simTimes$start
    , ".plotInterval" = 1L
    , ".plots" = c("object", "raw")
    , ".plotMaps" = FALSE
    , ".saveInitialTime" = NA
    , ".useCache" = eventCaching[1] # experiment doesn't like when init is cached
    , ".useParallel" = useParallel
  )
)

## objects will be saved at the start of the simulation (so they reflect the previous year)
simOutputs <- data.frame(expand.grid(objectName = "cohortData",
                                     saveTime = unique(seq(simTimes$start, simTimes$end, by = 1)),
                                     eventPriority = 1,
                                     stringsAsFactors = FALSE))
simOutputs <- rbind(simOutputs, data.frame(objectName = "pixelGroupMap",
                                           saveTime = unique(seq(simTimes$start, simTimes$end, by = 1)),
                                           eventPriority = 1))
simOutputs <- rbind(simOutputs, data.frame(objectName = "biomassMap",
                                           saveTime = simTimes$start,
                                           eventPriority = 1))

## in the first year, eventPriorities need to be set to AFTER the init event (which has priority 1)
simOutputs$eventPriority[simOutputs$saveTime == simTimes$start] <- 1.5

simObjects <- list(
  "rstLCC" = rstLCC2005
  , "sppEquiv" = sppEquivalencies_CA
  , "sppColorVect" = sppColorVect
  , "speciesLayers" = simOutSpeciesLayers$speciesLayers
  , "speciesParams" = speciesParams
  , "treed" = simOutSpeciesLayers$treed
  , "numTreed" = simOutSpeciesLayers$numTreed
  , "nonZeroCover" = simOutSpeciesLayers$nonZeroCover
  , "studyArea" = studyAreaS
  , "studyAreaLarge" = studyAreaL
)

## make a initialisation simList and run init events too
LandRBiomass_simInit <- Cache(simInitAndSpades
                              , times = simTimes
                              , params = simParams
                              , modules = simModules
                              , loadOrder = unlist(simModules)
                              , objects = simObjects
                              , paths = simPaths
                              , outputs = simOutputs
                              , events = "init"
                              , .plotInitialTime = NA
                              , userTags = "simInitAndInits"
                              , omitArgs = c("userTags", ".plotInitialTime"))
## save the simList
saveSimList(LandRBiomass_simInit, file.path(simPaths$outputPath, paste0("simInit", runName)))
```

```{r loadSimInit, include=FALSE, eval = !isInteractive, cache = FALSE}
LandRBiomass_simInit <- loadSimList(file.path("GitHubActionsSims", simDirName, runName, paste0("simInit", runName, ".qs")))
```

```{r objDiagram}
# look at the model structure and object exchange
objectDiagram(LandRBiomass_simInit, width = 1000, height = 2500)
```

## Run simulation

Here we run just one repetition

```{r runSimulation}
LandRBiomass_sim <- spades(LandRBiomass_simInit, .plotInitialTime = simTimes$start)
```

```{r loadSimulation, include=FALSE, eval = !isInteractive}
LandRBiomass_sim <- qs::qread(file.path("GitHubActionsSims", simDirName, runName, paste0("simList_LandRBiomass_sim_", runName, ".qs")))
```

If we were to run several repetitions, this would be how:

```{r runExperiment}
library(future)
plan("multiprocess", workers = 1)   ## each worker consumes roughly 10Gb
LandRBiomass_sim <- experiment2(
  sim1 = LandRBiomass_sim,
  clearSimEnv = TRUE,
  replicates = 10)
```

## Inspect simulation objects

We can use the `simList` objects to plot simulation objects, such as the input layers used for parameterisation.

```{r plotData, fig.show = "hold", eval = TRUE}
## study area within Saskatchewan province
## get Canadian provinces and subset to SK
can1 <- raster::getData('GADM', country = "CAN", level = 1, path = tempdir())
can1 <- can1[can1$NAME_1 == "Saskatchewan",]
can1 <- spTransform(can1, CRSobj = crs(LandRBiomass_simInit$studyArea))

plotStudyAreas <- ggplot() +
  layer_spatial(can1, fill = "grey90") + 
  layer_spatial(LandRBiomass_simInit$studyAreaLarge, fill = "darkgreen") +
  layer_spatial(LandRBiomass_simInit$studyArea, fill = "green") +
  labs(fill = "") +
  theme_void()


plotEcodist <- ggplot() +
  layer_spatial(LandRBiomass_simInit$ecoregionLayer, aes(fill = as.factor(ECODISTRIC))) + 
  labs(fill = "") +
  theme_void()
```

```{r plots, fig.show = "hold"}
## study area within Saskatchewan province
clearPlot(force = TRUE)
Plot(plotStudyAreas, title = " ")

## input stand biomass and age, ecological zonation (ecodistricts) and land-cover (LCC 2005)
clearPlot(force = TRUE)
Plot(LandRBiomass_simInit$rawBiomassMap,
     LandRBiomass_simInit$standAgeMap, 
     LandRBiomass_simInit$rstLCC,
     plotEcodist,
     title = c("kNN stand biomass", "kNN stand age", "land-cover", "ecodistricts"))

## species % cover
clearPlot(force = TRUE)
Plot(simOutSpeciesLayers$speciesLayers,
     title = names(simOutSpeciesLayers$speciesLayers))
```

```{r plots2, fig.show = 'asis', eval = !isInteractive, echo = FALSE}
plot(plotStudyAreas, main = " ")

## input stand biomass and age, ecological zonation (ecodistricts) and land-cover (LCC 2005)
plotEcodist <- ggplot() +
  layer_spatial(LandRBiomass_simInit$ecoregionLayer, aes(fill = as.factor(ECODISTRIC))) + 
  labs(fill = "") +
  theme_void()

plot(stack(LandRBiomass_simInit$rawBiomassMap,
     LandRBiomass_simInit$standAgeMap, 
     LandRBiomass_simInit$rstLCC),
     main = c("kNN stand biomass - kNN stand age - land-cover"))

plot(plotEcodist, main = "ecolocations")
## species % cover
plot(simOutSpeciesLayers$speciesLayers,
     main = paste(names(simOutSpeciesLayers$speciesLayers), collapse = ", "))
```



Similarly, we can have a look at the species traits values used in the simulation directly from the `simList` object (although we also chose to save them).

```{r speciesTraits, eval=FALSE}
LandRBiomass_simInit$species
LandRBiomass_simInit$minRelativeB ## can be spatially varying, but identical across ecolocation (AKA ecoregion)
LandRBiomass_simInit$sufficientLight
LandRBiomass_simInit$speciesEcoregion
```

For example, these were the (spatially) invariant species traits used in the simulation:

```{r speciesTraitsShow, echo=FALSE, eval = TRUE}
knitr::kable(LandRBiomass_simInit$species, caption = "Invariant species traits")
```

# Validation

Here we run the validation on the outputs of just one repetition.

We begin by preparing all the inputs necessary for the `Biomass_validationKNN` module.

```{r validationPrep}
## get the  land-cover change map (needed to have an RTM first, so get it from the simInitList)
## /!\ it is assumed that the filename of the raster in the simList corresponds to the raster found in disk.
## this may not be the case if the simulations were run in another machine and saved rasters were not imported.

validationPaths <- list(cachePath = file.path("R/SpaDES/cache", simDirName)
                        , modulePath = file.path("R/SpaDES/m")
                        , inputPath = file.path("R/SpaDES/inputs")
                        , outputPath = file.path("R/SpaDES/validation", simDirName))

source("R/SpaDES/3_simObjects4Valid.R")

## PARAMETERS FOR VALIDATION MODULE
## in this case all reps have the same parameters, so we can use the first rep to get the values
validationTimes <- list(start = 1, end = 1)
validationParams <- list(
  Biomass_validationKNN = list(
    "minCoverThreshold" = params(LandRBiomass_simInit)$Biomass_borealDataPrep$minCoverThreshold
    , "pixelGroupBiomassClass" = params(LandRBiomass_simInit)$Biomass_borealDataPrep$pixelGroupBiomassClass
    , "deciduousCoverDiscount" = params(LandRBiomass_simInit)$Biomass_borealDataPrep$deciduousCoverDiscount
    , "sppEquivCol" = params(LandRBiomass_simInit)$Biomass_borealDataPrep$sppEquivCol
    , "validationReps" = as.integer(1:10)  ## or length of simLists
    , "validationYears" = as.integer(c(2001, 2011))
    , ".useCache" = eventCaching
  )
)

validationObjects <- list(
  "biomassMap" = biomassMap
  , "rasterToMatch" = rasterToMatch
  , "rawBiomassMapStart" = rawBiomassMap
  , "rstLCChange" = rstLCChangeAllbin
  , "simulationOutputs" = simulationOutputs
  , "speciesLayersStart" = speciesLayers
  , "sppColorVect" = LandRBiomass_simInit$sppColorVect
  , "sppEquiv" = LandRBiomass_simInit$sppEquiv
  , "standAgeMapStart" = standAgeMap
  , "studyArea" = LandRBiomass_simInit$studyArea
)

## the following objects are only saved once at the end of year 0/beggining of year 1 (they don't change)
validationOutputs <- data.frame(expand.grid(objectName = c("rawBiomassMapStart"),
                                            saveTime = c(validationTimes$start),
                                            eventPriority = 1),
                                stringsAsFactors = FALSE)
validationOutputs <- rbind(validationOutputs, data.frame(objectName = "rawBiomassMapEnd",
                                                         saveTime = c(validationTimes$start),
                                                         eventPriority = 1))
validationOutputs <- rbind(validationOutputs, data.frame(objectName = "standAgeMapStart",
                                                         saveTime = c(validationTimes$start),
                                                         eventPriority = 1))
validationOutputs <- rbind(validationOutputs, data.frame(objectName = "standAgeMapEnd",
                                                         saveTime = c(validationTimes$start),
                                                         eventPriority = 1))
validationOutputs <- rbind(validationOutputs, data.frame(objectName = "speciesLayersStart",
                                                         saveTime = c(validationTimes$start),
                                                         eventPriority = 1))
validationOutputs <- rbind(validationOutputs, data.frame(objectName = "speciesLayersEnd",
                                                         saveTime = c(validationTimes$start),
                                                         eventPriority = 1))
```

We can now run the validation:

```{r validationRun}
LandRBiomass_validation <- simInitAndSpades(times = validationTimes
                                            , params = validationParams
                                            , modules = "Biomass_validationKNN"
                                            , objects = validationObjects
                                            , outputs = validationOutputs
                                            , paths = validationPaths
                                            , .plotInitialTime = validationTimes$start) 
```
